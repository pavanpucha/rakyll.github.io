<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stdlib on Go, the unwritten parts</title>
    <link>https://rakyll.org/tags/stdlib/</link>
    <description>Recent content in Stdlib on Go, the unwritten parts</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Jul 2017 11:27:27 -0400</lastBuildDate>
    
	<atom:link href="https://rakyll.org/tags/stdlib/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Profiler labels in Go</title>
      <link>https://rakyll.org/profiler-labels/</link>
      <pubDate>Mon, 03 Jul 2017 11:27:27 -0400</pubDate>
      
      <guid>https://rakyll.org/profiler-labels/</guid>
      <description>Go 1.9 is introducing profiler labels, a way to add arbitrary key-values to the samples collected by the CPU profiler. CPU profilers collect and output hot spots where the CPU spent most time in when executing. A typical CPU profiler output is primarily reports the location of these spots as function name, source file/line, etc. By looking at the data, you can also examine which parts of the code invoked these spots.</description>
    </item>
    
    <item>
      <title>HTTP/2 Server Push</title>
      <link>https://rakyll.org/http2push/</link>
      <pubDate>Sat, 10 Dec 2016 11:27:27 -0400</pubDate>
      
      <guid>https://rakyll.org/http2push/</guid>
      <description>Go 1.8 is going to feature support for HTTP/2 server push.
HTTP/2 has many features designed to make the Web faster. One of those features is the server push, the ability to send resources before the client asks for it. This feature enables websites to push assets like JavaScript and CSS files before waiting for the web page to be loaded and asking for those resources.
net/http package will support server push by exposing a Pusher API that will be supported by HTTP/2 ResponseWriters.</description>
    </item>
    
    <item>
      <title>Using contexts to avoid leaking goroutines</title>
      <link>https://rakyll.org/leakingctx/</link>
      <pubDate>Tue, 25 Oct 2016 11:27:27 -0400</pubDate>
      
      <guid>https://rakyll.org/leakingctx/</guid>
      <description>The context package makes it possible to manage a chain of calls within the same call path by signaling context&amp;rsquo;s Done channel.
In this article, we will examine how to use the context package to avoid leaking goroutines.
Assume, you have a function that starts a goroutine internally. Once this function is called, the caller may not be able to terminate the goroutine started by the function.
// gen is a broken generator that will leak a goroutine.</description>
    </item>
    
  </channel>
</rss>